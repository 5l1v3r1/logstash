input {
  lumberjack {
    port => 5000
    type => "ctrllogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
  lumberjack {
    port => 5001
    type => "wwwlogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
  lumberjack {
    port => 5002
    type => "maillogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
  udp {
    port => 25826
    type => "collectd"
    buffer_size => 1452
    codec => collectd { }
  }
}

filter {
  if [type] == "syslog" {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid:int}\])?: %{GREEDYDATA:syslog_message}" }
      add_field => {
		     "syslog_received_at" => "%{@timestamp}"
		     "syslog_received_from" => "%{host}"
      }
    }
    syslog_pri {
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      timezone => "Asia/Tokyo"
    }
    # postfix details
    if [syslog_program] == "postfix/smtpd" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTPD}" }
      }
    }
    if [syslog_program] == "postfix/smtp" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTP}" }
      }
    }
    if [syslog_program] == "postfix/bounce" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_BOUNCE}" }
      }
    }
    if [syslog_program] == "postfix/qmgr" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_QMGR}" }
      }
    }
    if [syslog_program] == "postfix/anvil" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_ANVIL}" }
      }
    }
    if [syslog_program] == "postfix/cleanup" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_CLEANUP}" }
      }
    }
    if [syslog_program] == "postfix/dnsblog" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_DNSBLOG}" }
      }
    }
    if [syslog_program] == "postfix/master" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_MASTER}" }
      }
    }
    if [syslog_program] == "postfix/pickup" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_PICKUP}" }
      }
    }
    if [syslog_program] == "postfix/pipe" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_PIPE}" }
      }
    }
    if [syslog_program] == "postfix/postdrop" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_POSTDROP}" }
      }
    }
    if [syslog_program] == "postfix/postscreen" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_POSTSCREEN}" }
      }
    }
    if [syslog_program] == "postfix/sendmail" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SENDMAIL}" }
      }
    }
    if [syslog_program] == "postfix/tlsmgr" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TLSMGR}" }
      }
    }
    if [syslog_program] == "postfix/tlsproxy" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TLSPROXY}" }
      }
    }
    if [syslog_program] == "postfix/trivial-rewrite" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TRIVIAL_REWRITE}" }
      }
    }
    # add
    if [syslog_program] == "postfix/lmtp" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTP}" }
      }
    }
    if [syslog_program] == "postfix/local" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTP}" }
      }
    }
    if [syslog_program] == "postfix/amavisd/smtpd" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTPD}" }
      }
    }

    if [syslog_program] =~ /^postfix.*\// {
      mutate {
	replace => [ "type", "postfix" ]
      }
      # process key-value data is it exists
      if [postfix_keyvalue_data] {
	kv {
	  source => "postfix_keyvalue_data"
	  include_keys => [ "from", "to", "orig_to", "proto", "helo", "size", "nrcpt", "client", "relay", "delays", "dsn", "uid", "status", "message-id" ]
	  trim => "<>,"
	  prefix => "postfix_"
	  remove_field => [ "postfix_keyvalue_data" ]
	}
	# some post processing of key-value data
	if [postfix_client] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_client" => "%{POSTFIX_CLIENT_INFO}" }
	    tag_on_failure => [ "_grok_kv_postfix_client_nomatch" ]
	    remove_field => [ "postfix_client" ]
	  }
	}
	if [postfix_relay] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_relay" => "%{POSTFIX_RELAY_INFO}" }
	    tag_on_failure => [ "_grok_kv_postfix_relay_nomatch" ]
	    remove_field => [ "postfix_relay" ]
	  }
	}
	if [postfix_delays] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_delays" => "%{POSTFIX_DELAYS}" }
	    tag_on_failure => [ "_grok_kv_postfix_delays_nomatch" ]
	    remove_field => [ "postfix_delays" ]
	  }
	}
	if [postfix_from] == "" {
	  mutate {
	    replace => [ "postfix_from", "NULL" ]
	  }
	}
      }
      # Do some data type conversions
      mutate {
	convert => [
	# list of integer fields
	"postfix_nrcpt", "integer",
	"postfix_size", "integer",
	#"postfix_uid", "integer",
	# list of float fields
	"postfix_delay", "float"
	]
      }
      if [postfix_client_ip] {
	geoip {
	  database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	  source => "postfix_client_ip"
	  target => "postfix_geoip"
	  add_field => {
			 "[postfix_geoip][coordinates]" => "%{[postfix_geoip][longitude]}"
			 "[postfix_geoip][coordinates]" => "%{[postfix_geoip][latitude]}"
	  }
	}
	mutate {
	  convert => [ "[postfix_geoip][coordinates]", "float" ]
	}
      }
    }

    if [syslog_program] == "sshd" {
      grok {
        patterns_dir => "/etc/logstash/patterns"
        match => { "syslog_message" => "%{SSHD_LOG}" }
      }
      if [sshd_client_ip] {
	geoip {
	  database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	  source => "sshd_client_ip"
	  target => "sshd_geoip"
	  add_field => {
			 "[sshd_geoip][coordinates]" => "%{[sshd_geoip][longitude]}"
			 "[sshd_geoip][coordinates]" => "%{[sshd_geoip][latitude]}"
	  }
	}
	mutate {
	  convert => [ "[sshd_geoip][coordinates]", "float" ]
	}
      }
    }
  }

  if [type] == "apache" {
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{APACHE_COMBINED}" }
    }
    date {
      match => [ "apache_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      timezone => "Asia/Tokyo"
    }
    if [apache_client_ip] {
      geoip {
	database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	source => "apache_client_ip"
	target => "apache_geoip"
	add_field => {
		       "[apache_geoip][coordinates]" => "%{[apache_geoip][longitude]}"
		       "[apache_geoip][coordinates]" => "%{[apache_geoip][latitude]}"
	}
      }
      mutate {
	convert => [ "[apache_geoip][coordinates]", "float" ]
	add_field => { "apache_client_hostname" => "%{apache_client_ip}" }
      }
      dns {
	reverse => [ "apache_client_hostname" ]
	action => "replace"
      }
    }
    if [apache_agent] != "-" and [apache_agent] != "" {
      useragent {
        source => "apache_agent"
        target => "apache_useragent"
      }
      if [apache_agent] =~ /Tiny\ Tiny\ RSS/ {
        mutate {
          add_field => { "apache_robot" => "Tiny_Tiny_RSS" }
        }
      }
      if [apache_agent] =~ /Windows\-RSS\-Platform/ {
        mutate {
          add_field => { "apache_robot" => "Windows-RSS-Platform" }
        }
      }
      if [apache_agent] =~ /DotBot/ {
        mutate {
          add_field => { "apache_robot" => "DotBot" }
        }
      }
      if [apache_agent] =~ /FeedFetcher/ {
        mutate {
          add_field => { "apache_robot" => "FeedFetcher" }
        }
      }
      if [apache_agent] =~ /meanpathbot/ {
        mutate {
          add_field => { "apache_robot" => "meanpathbot" }
        }
      }
      if [apache_agent] =~ /Twitterbot/ {
        mutate {
          add_field => { "apache_robot" => "Twitterbot" }
        }
      }
      if [apache_agent] =~ /Feedly/ {
        mutate {
          add_field => { "apache_robot" => "Feedly" }
        }
      }
      if [apache_agent] =~ /CRAZYWEBCRAWLER/ {
        mutate {
          add_field => { "apache_robot" => "CRAZYWEBCRAWLER" }
        }
      }
      if [apache_agent] =~ /AhrefsBot/ {
        mutate {
          add_field => { "apache_robot" => "AhrefsBot" }
        }
      }
      if [apache_agent] =~ /everrss/ {
        mutate {
          add_field => { "apache_robot" => "everrss" }
        }
      }
      if [apache_agent] =~ /Feedeen/ {
        mutate {
          add_field => { "apache_robot" => "Feedeen" }
        }
      }
      if [apache_agent] =~ /Yandex/ {
        mutate {
          add_field => { "apache_robot" => "Yandex" }
        }
      }
      if [apache_agent] =~ /Googlebot/ {
        mutate {
          add_field => { "apache_robot" => "Googlebot" }
        }
      }
      if [apache_agent] =~ /bingbot/ {
        mutate {
          add_field => { "apache_robot" => "bingbot" }
        }
      }
      if [apache_agent] =~ /BingPreview/ {
        mutate {
          add_field => { "apache_robot" => "BingPreview" }
        }
      }
      if [apache_agent] =~ /Yahoo/ {
        mutate {
          add_field => { "apache_robot" => "Yahoo" }
        }
      }
      if [apache_agent] =~ /Feedbin/ {
        mutate {
          add_field => { "apache_robot" => "Feedbin" }
        }
      }
      if [apache_agent] =~ /FreshReader/ {
        mutate {
          add_field => { "apache_robot" => "FreshReader" }
        }
      }
      if [apache_agent] =~ /AlexaToolbar/ {
        mutate {
          add_field => { "apache_robot" => "AlexaToolbar" }
        }
      }
      if [apache_agent] =~ /Baiduspider/ {
        mutate {
          add_field => { "apache_robot" => "Baiduspider" }
        }
      }
      # bad bot
      if [apache_agent] =~ /360Spider/ {
        mutate {
          add_field => { "apache_robot" => "360Spider" }
        }
      }
      if [apache_agent] =~ /MJ12bot/ {
        mutate {
          add_field => { "apache_robot" => "MJ12bot" }
        }
      }
    }
    if [apache_request] {
      ruby {
        code => "event['apache_extension'] = File.extname(event['apache_request'].split('?')[0]).delete('.')"
      }
      if [apache_extension] == "" or [apache_extension] !~ /^[a-zA-Z0-9]{2,4}$/ {
	mutate {
	  remove_field => [ "apache_extension" ]
	}
      }
    }
  }

  if [type] == "apache-other-vhost" {
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{APACHE_OTHER_VHOST}" }
    }
    date {
      match => [ "apache_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      timezone => "Asia/Tokyo"
    }
    if [apache_client_ip] {
      geoip {
	database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	source => "apache_client_ip"
	target => "apache_geoip"
	add_field => {
		       "[apache_geoip][coordinates]" => "%{[apache_geoip][longitude]}"
		       "[apache_geoip][coordinates]" => "%{[apache_geoip][latitude]}"
	}
      }
      mutate {
	convert => [ "[apache_geoip][coordinates]", "float" ]
	add_field => { "apache_client_hostname" => "%{apache_client_ip}" }
      }
      dns {
	reverse => [ "apache_client_hostname" ]
	action => "replace"
      }
    }
    if [apache_agent] != "-" and [apache_agent] != "" {
      useragent {
	source => "apache_agent"
	target => "apache_useragent"
      }
      if [apache_agent] =~ /Tiny\ Tiny\ RSS/ {
        mutate {
          add_field => { "apache_robot" => "Tiny_Tiny_RSS" }
        }
      }
      if [apache_agent] =~ /Windows\-RSS\-Platform/ {
        mutate {
          add_field => { "apache_robot" => "Windows-RSS-Platform" }
        }
      }
      if [apache_agent] =~ /DotBot/ {
        mutate {
          add_field => { "apache_robot" => "DotBot" }
        }
      }
      if [apache_agent] =~ /FeedFetcher/ {
        mutate {
          add_field => { "apache_robot" => "FeedFetcher" }
        }
      }
      if [apache_agent] =~ /meanpathbot/ {
        mutate {
          add_field => { "apache_robot" => "meanpathbot" }
        }
      }
      if [apache_agent] =~ /Twitterbot/ {
        mutate {
          add_field => { "apache_robot" => "Twitterbot" }
        }
      }
      if [apache_agent] =~ /Feedly/ {
        mutate {
          add_field => { "apache_robot" => "Feedly" }
        }
      }
      if [apache_agent] =~ /CRAZYWEBCRAWLER/ {
        mutate {
          add_field => { "apache_robot" => "CRAZYWEBCRAWLER" }
        }
      }
      if [apache_agent] =~ /AhrefsBot/ {
        mutate {
          add_field => { "apache_robot" => "AhrefsBot" }
        }
      }
      if [apache_agent] =~ /everrss/ {
        mutate {
          add_field => { "apache_robot" => "everrss" }
        }
      }
      if [apache_agent] =~ /Feedeen/ {
        mutate {
          add_field => { "apache_robot" => "Feedeen" }
        }
      }
      if [apache_agent] =~ /Yandex/ {
        mutate {
          add_field => { "apache_robot" => "Yandex" }
        }
      }
      if [apache_agent] =~ /Googlebot/ {
        mutate {
          add_field => { "apache_robot" => "Googlebot" }
        }
      }
      if [apache_agent] =~ /bingbot/ {
        mutate {
          add_field => { "apache_robot" => "bingbot" }
        }
      }
      if [apache_agent] =~ /BingPreview/ {
        mutate {
          add_field => { "apache_robot" => "BingPreview" }
        }
      }
      if [apache_agent] =~ /Yahoo/ {
        mutate {
          add_field => { "apache_robot" => "Yahoo" }
        }
      }
      if [apache_agent] =~ /Feedbin/ {
        mutate {
          add_field => { "apache_robot" => "Feedbin" }
        }
      }
      if [apache_agent] =~ /FreshReader/ {
        mutate {
          add_field => { "apache_robot" => "FreshReader" }
        }
      }
      if [apache_agent] =~ /AlexaToolbar/ {
        mutate {
          add_field => { "apache_robot" => "AlexaToolbar" }
        }
      }
      if [apache_agent] =~ /Baiduspider/ {
        mutate {
          add_field => { "apache_robot" => "Baiduspider" }
        }
      }
      # bad bot
      if [apache_agent] =~ /360Spider/ {
        mutate {
          add_field => { "apache_robot" => "360Spider" }
        }
      }
      if [apache_agent] =~ /MJ12bot/ {
        mutate {
          add_field => { "apache_robot" => "MJ12bot" }
        }
      }
    }
    if [apache_request] {
      ruby {
	code => "event['apache_extension'] = File.extname(event['apache_request'].split('?')[0]).delete('.')"
      }
      if [apache_extension] == "" or [apache_extension] !~ /^[a-zA-Z0-9]{2,4}$/ {
	mutate {
	  remove_field => [ "apache_extension" ]
	}
      }
    }
  }

  if [type] == "apache-error" {
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{APACHE_ERROR}" }
    }
    date {
      match => [ "apache_error_timestamp", "EEE MMM dd HH:mm:ss yyyy" ]
      timezone => "Asia/Tokyo"
    }
    if [apache_error_client_ip] {
      geoip {
	database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	source => "apache_error_client_ip"
	target => "apache_error_geoip"
	add_field => {
		       "[apache_error_geoip][coordinates]" => "%{[apache_error_geoip][longitude]}"
		       "[apache_error_geoip][coordinates]" => "%{[apache_error_geoip][latitude]}"
	}
      }
      mutate {
	convert => [ "[apache_error_geoip][coordinates]", "float" ]
	add_field => { "apache_error_client_hostname" => "%{apache_error_client_ip}" }
      }
      dns {
	reverse => [ "apache_error_client_hostname" ]
	action => "replace"
      }
    }
  }
}

output {
  redis {
    host => "127.0.0.1"
    data_type => "list"
    key => "logstash"
  }
}
