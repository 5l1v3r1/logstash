input {
  lumberjack {
    port => 5000
    type => "ctrllogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
  lumberjack {
    port => 5001
    type => "wwwlogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
  lumberjack {
    port => 5002
    type => "maillogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
}

filter {
  if [type] == "syslog" {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid:int}\])?: %{GREEDYDATA:syslog_message}" }
      add_field => [ "syslog_received_at", "%{@timestamp}" ]
      add_field => [ "syslog_received_from", "%{host}" ]
    }
    syslog_pri {
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      timezone => "Asia/Tokyo"
    }
    # postfix details
    if [syslog_program] == "postfix/smtpd" {
       grok {
	 patterns_dir => "/etc/logstash/patterns"
	 match => [ "syslog_message", "%{POSTFIX_SMTPD}" ]
       }
    }
    if [syslog_program] == "postfix/smtp" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_SMTP}" ]
       }
    }
    if [syslog_program] == "postfix/bounce" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_BOUNCE}" ]
       }
    }
    if [syslog_program] == "postfix/qmgr" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_QMGR}" ]
       }
    }
    if [syslog_program] == "postfix/anvil" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_ANVIL}" ]
       }
    }
    if [syslog_program] == "postfix/cleanup" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_CLEANUP}" ]
       }
    }
    if [syslog_program] == "postfix/dnsblog" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_DNSBLOG}" ]
       }
    }
    if [syslog_program] == "postfix/master" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_MASTER}" ]
       }
    }
    if [syslog_program] == "postfix/pickup" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_PICKUP}" ]
       }
    }
    if [syslog_program] == "postfix/pipe" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_PIPE}" ]
       }
    }
    if [syslog_program] == "postfix/postdrop" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_POSTDROP}" ]
       }
    }
    if [syslog_program] == "postfix/postscreen" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_POSTSCREEN}" ]
       }
    }
    if [syslog_program] == "postfix/sendmail" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_SENDMAIL}" ]
       }
    }
    if [syslog_program] == "postfix/tlsmgr" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_TLSMGR}" ]
       }
    }
    if [syslog_program] == "postfix/tlsproxy" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_TLSPROXY}" ]
       }
    }
    if [syslog_program] == "postfix/trivial-rewrite" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_TRIVIAL_REWRITE}" ]
       }
    }
    # add
    if [syslog_program] == "postfix/lmtp" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_SMTP}" ]
       }
    }
    if [syslog_program] == "postfix/local" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_SMTP}" ]
       }
    }
    if [syslog_program] == "postfix/amavisd/smtpd" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{POSTFIX_SMTPD}" ]
       }
    }

    if [syslog_program] =~ /^postfix.*\// {
       mutate {
         replace => [ "type", "postfix" ]
       }
       # process key-value data is it exists
       if [postfix_keyvalue_data] {
         kv {
	   source => "postfix_keyvalue_data"
	   include_keys => ["from", "to", "orig_to", "proto", "helo", "size", "nrcpt", "client", "relay", "delays", "dsn", "uid", "status", "message-id"]
	   trim => "<>,"
	   prefix => "postfix_"
	   remove_field => [ "postfix_keyvalue_data" ]
	 }
	 # some post processing of key-value data
	 if [postfix_client] {
	   grok {
	     patterns_dir => "/etc/logstash/patterns"
	     match => ["postfix_client", "%{POSTFIX_CLIENT_INFO}"]
	     tag_on_failure => [ "_grok_kv_postfix_client_nomatch" ]
	     remove_field => [ "postfix_client" ]
	   }
	 }
	 if [postfix_relay] {
	   grok {
	     patterns_dir => "/etc/logstash/patterns"
	     match => ["postfix_relay", "%{POSTFIX_RELAY_INFO}"]
	     tag_on_failure => [ "_grok_kv_postfix_relay_nomatch" ]
	     remove_field => [ "postfix_relay" ]
	   }
	 }
	 if [postfix_delays] {
	   grok {
	     patterns_dir => "/etc/logstash/patterns"
	     match => ["postfix_delays", "%{POSTFIX_DELAYS}"]
	     tag_on_failure => [ "_grok_kv_postfix_delays_nomatch" ]
	     remove_field => [ "postfix_delays" ]
	   }
	 }
       }
       # Do some data type conversions
       mutate {
         convert => [
	 # list of integer fields
	 "postfix_nrcpt", "integer",
	 "postfix_size", "integer",
	 #"postfix_uid", "integer",
	 # list of float fields
	 "postfix_delay", "float"
	 ]
      }
      # geoip test
      geoip {
        database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
        source => "postfix_client_ip"
        target => "postfix_geoip"
        add_field => ["[postfix_geoip][coordinates]","%{[postfix_geoip][longitude]}"]
        add_field => ["[postfix_geoip][coordinates]","%{[postfix_geoip][latitude]}"]
      } 
      mutate {
        convert => [ "[postfix_geoip][coordinates]", "float" ]
      }
    }
    # TEST SSHD
    if [syslog_program] == "sshd" {
       grok {
         patterns_dir => "/etc/logstash/patterns"
         match => [ "syslog_message", "%{SSHD_LOG}" ]
       }
       # geoip test
       geoip {
         database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	 source => "sshd_client_ip"
	 target => "sshd_geoip"
	 add_field => ["[sshd_geoip][coordinates]","%{[sshd_geoip][longitude]}"]
	 add_field => ["[sshd_geoip][coordinates]","%{[sshd_geoip][latitude]}"]
      } 
      mutate {
        convert => [ "[sshd_geoip][coordinates]", "float" ]
      }
    }
  }

  if [type] == "apache" {
    # apache
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => [ "message", "%{APACHE_COMBINED}" ]
    }
    date {
      match => [ "apache_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      timezone => "Asia/Tokyo"
    }
    # geoip test
    geoip {
      database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
      source => "apache_client_ip"
      target => "apache_geoip"
      add_field => ["[apache_geoip][coordinates]","%{[apache_geoip][longitude]}"]
      add_field => ["[apache_geoip][coordinates]","%{[apache_geoip][latitude]}"]
    } 
    mutate {
      convert => [ "[apache_geoip][coordinates]", "float" ]
    }
    if [apache_agent] != "-" and [apache_agent] != "" {
      useragent {
        source => "apache_agent"
        target => "apache_useragent"
      } 
    }
    if [apache_request] {
      ruby {
        code => "event['apache_extension'] = File.extname(event['apache_request'].split('?')[0]).delete('.')"
      }
      if [apache_extension] == "" or [apache_extension] !~ /^[a-zA-Z0-9]{2,4}$/ {
        mutate {
	  remove_field => ["apache_extension"]
	}
      }
    }
  }

  if [type] == "apache-other-vhost" {
    # apache
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => [ "message", "%{APACHE_OTHER_VHOST}" ]
    }
    date {
      match => [ "apache_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      timezone => "Asia/Tokyo"
    }
    # geoip test
    geoip {
      database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
      source => "apache_client_ip"
      target => "apache_geoip"
      add_field => ["[apache_geoip][coordinates]","%{[apache_geoip][longitude]}"]
      add_field => ["[apache_geoip][coordinates]","%{[apache_geoip][latitude]}"]
    } 
    mutate {
      convert => [ "[apache_geoip][coordinates]", "float" ]
    }
    if [apache_agent] != "-" and [apache_agent] != "" {
      useragent {
        source => "apache_agent"
        target => "apache_useragent"
      } 
    }
    if [apache_request] {
      ruby {
        code => "event['apache_extension'] = File.extname(event['apache_request'].split('?')[0]).delete('.')"
      }
      if [apache_extension] == "" {
        mutate {
	  remove_field => ["apache_extension"]
	}
      }
    }
  }

  if [type] == "apache-error" {
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => [ "message", "%{APACHE_ERROR}" ]
    }
    date {
      match => [ "apache_error_timestamp", "EEE MMM dd HH:mm:ss yyyy" ]
      timezone => "Asia/Tokyo"
    }
    # geoip test
    geoip {
      database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
      source => "apache_error_client_ip"
      target => "apache_error_geoip"
      add_field => ["[apache_error_geoip][coordinates]","%{[apache_error_geoip][longitude]}"]
      add_field => ["[apache_error_geoip][coordinates]","%{[apache_error_geoip][latitude]}"]
    } 
    mutate {
      convert => [ "[apache_error_geoip][coordinates]", "float" ]
    }
  }
}

output {
  redis {
    host => "127.0.0.1"
    data_type => "list"
    key => "logstash"
  }
}
