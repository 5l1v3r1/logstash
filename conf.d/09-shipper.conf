input {
  lumberjack {
    port => 5000
    type => "ctrllogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
  lumberjack {
    port => 5001
    type => "wwwlogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
  lumberjack {
    port => 5002
    type => "maillogs"
    ssl_certificate => "/etc/logstash/logstash-forwarder.crt"
    ssl_key => "/etc/logstash/logstash-forwarder.key"
  }
  udp {
    port => 25826
    type => "collectd"
    buffer_size => 1452
    codec => collectd {
      authfile => "/etc/logstash/collectd.auth"
      security_level => "Encrypt" 
    }
  }
}

filter {
  if [type] == "syslog" {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid:int}\])?: %{GREEDYDATA:syslog_message}" }
      add_field => {
	"syslog_received_at" => "%{@timestamp}"
	"syslog_received_from" => "%{host}"
      }
    }
    syslog_pri {
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      timezone => "Asia/Tokyo"
    }
    # postfix details
    if [syslog_program] =~ /^postfix.*\/smtpd$/ {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTPD}" }
      }
    }
    if [syslog_program] == "postfix/smtp" or [syslog_program] == "postfix/lmtp" or [syslog_program] == "postfix/local" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTP}" }
      }
    }
    if [syslog_program] == "postfix/bounce" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_BOUNCE}" }
      }
    }
    if [syslog_program] == "postfix/qmgr" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_QMGR}" }
      }
    }
    if [syslog_program] == "postfix/anvil" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_ANVIL}" }
      }
    }
    if [syslog_program] == "postfix/cleanup" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_CLEANUP}" }
      }
    }
    if [syslog_program] == "postfix/dnsblog" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_DNSBLOG}" }
      }
    }
    if [syslog_program] == "postfix/master" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_MASTER}" }
      }
    }
    if [syslog_program] == "postfix/pickup" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_PICKUP}" }
      }
    }
    if [syslog_program] == "postfix/pipe" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_PIPE}" }
      }
    }
    if [syslog_program] == "postfix/postdrop" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_POSTDROP}" }
      }
    }
    if [syslog_program] == "postfix/postscreen" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_POSTSCREEN}" }
      }
    }
    if [syslog_program] == "postfix/sendmail" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SENDMAIL}" }
      }
    }
    if [syslog_program] == "postfix/tlsmgr" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TLSMGR}" }
      }
    }
    if [syslog_program] == "postfix/tlsproxy" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TLSPROXY}" }
      }
    }
    if [syslog_program] == "postfix/trivial-rewrite" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TRIVIAL_REWRITE}" }
      }
    }

    if [syslog_program] =~ /^postfix.*\// {
      mutate {
	replace => { "type" => "postfix" }
      }
      # process key-value data is it exists
      if [postfix_keyvalue_data] {
	kv {
	  source => "postfix_keyvalue_data"
	  include_keys => [ "from", "to", "orig_to", "proto", "helo", "size", "nrcpt", "client", "relay", "delay", "delays", "dsn", "uid", "status", "message-id" ]
	  trim => "<>,"
	  prefix => "postfix_"
	  remove_field => [ "postfix_keyvalue_data" ]
	}
	# some post processing of key-value data
	if [postfix_client] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_client" => "%{POSTFIX_CLIENT_INFO}" }
	    tag_on_failure => [ "_grok_kv_postfix_client_nomatch" ]
	    remove_field => [ "postfix_client" ]
	  }
	}
	if [postfix_relay] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_relay" => "%{POSTFIX_RELAY_INFO}" }
	    tag_on_failure => [ "_grok_kv_postfix_relay_nomatch" ]
	    remove_field => [ "postfix_relay" ]
	  }
	}
	if [postfix_delays] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_delays" => "%{POSTFIX_DELAYS}" }
	    tag_on_failure => [ "_grok_kv_postfix_delays_nomatch" ]
	    remove_field => [ "postfix_delays" ]
	  }
	}
	if [postfix_from] == "" {
	  mutate {
	    replace => { "postfix_from" => "NULL" }
	  }
	}
      }
      # Do some key-value data type conversions
      mutate {
	convert => {
	  "postfix_nrcpt" => "integer"
	  "postfix_size" => "integer"
	  "postfix_uid" => "integer"
	  "postfix_delay" => "float"
	}
      }
      if [postfix_client_ip] {
	geoip {
	  database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	  source => "postfix_client_ip"
	  target => "postfix_geoip"
	}
      }
    }

    if [syslog_program] == "sshd" {
      grok {
        patterns_dir => "/etc/logstash/patterns"
        match => { "syslog_message" => "%{SSHD_LOG}" }
      }
      if [sshd_client_ip] {
	geoip {
	  database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	  source => "sshd_client_ip"
	  target => "sshd_geoip"
	}
      }
    }
  }

  if [type] == "apache" or [type] == "apache-other-vhost" {
    if [type] == "apache-other-vhost" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "message" => "%{APACHE_OTHER_VHOST}" }
      }
    } else {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "message" => "%{APACHE_COMBINED}" }
      }
    }
    date {
      match => [ "apache_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      timezone => "Asia/Tokyo"
    }
    if [apache_client_ip] {
      geoip {
	database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	source => "apache_client_ip"
	target => "apache_geoip"
      }
      mutate {
	add_field => { "apache_client_hostname" => "%{apache_client_ip}" }
      }
      dns {
	reverse => [ "apache_client_hostname" ]
	action => "replace"
      }
    }
    if [apache_agent] {
      useragent {
        source => "apache_agent"
        target => "apache_useragent"
      }
      if [apache_agent] =~ /^\"robots\"$/ {
        mutate {
          add_field => { "apache_robot" => "robots" }
        }
      }
      if [apache_agent] =~ /^\"\-\"$/ {
        mutate {
          add_field => { "apache_robot" => "-" }
        }
      }
      if [apache_agent] =~ /Java/ {
        mutate {
          add_field => { "apache_robot" => "Java" }
        }
      }
      if [apache_agent] =~ /curl/ {
        mutate {
          add_field => { "apache_robot" => "curl" }
        }
      }
      if [apache_agent] =~ /Wget/ {
        mutate {
          add_field => { "apache_robot" => "Wget" }
        }
      }
      if [apache_agent] =~ /libwww\-perl/ {
        mutate {
          add_field => { "apache_robot" => "libwww-perl" }
        }
      }
      if [apache_agent] =~ /NetcraftSurveyAgent/ {
        mutate {
          add_field => { "apache_robot" => "NetcraftSurveyAgent" }
        }
      }
      if [apache_agent] =~ /Netcraft\ Web\ Server\ Survey/ {
        mutate {
          add_field => { "apache_robot" => "Netcraft_Web_Server_Survey" }
        }
      }
      if [apache_agent] =~ /Cloud\ mapping\ experiment/ {
        mutate {
          add_field => { "apache_robot" => "Cloud_mapping_experiment" }
        }
      }
      if [apache_agent] =~ /msnbot\-media/ {
        mutate {
          add_field => { "apache_robot" => "msnbot-media" }
        }
      }
      if [apache_agent] =~ /Hatena\ Pagetitle\ Agent/ {
        mutate {
          add_field => { "apache_robot" => "Hatena_Pagetitle_Agent" }
        }
      }
      if [apache_agent] =~ /Google\ favicon/ {
        mutate {
          add_field => { "apache_robot" => "Google_favicon" }
        }
      }
      if [apache_agent] =~ /PagesInventory/ {
        mutate {
          add_field => { "apache_robot" => "PagesInventory" }
        }
      }
      if [apache_agent] =~ /TurnitinBot/ {
        mutate {
          add_field => { "apache_robot" => "TurnitinBot" }
        }
      }
      if [apache_agent] =~ /Superfeedr\ bot/ {
        mutate {
          add_field => { "apache_robot" => "Superfeedr_bot" }
        }
      }
      if [apache_agent] =~ /Scrapy/ {
        mutate {
          add_field => { "apache_robot" => "special_archiver" }
        }
      }
      if [apache_agent] =~ /special_archiver/ {
        mutate {
          add_field => { "apache_robot" => "special_archiver" }
        }
      }
      if [apache_agent] =~ /Hatena\ Star\ UserAgent/ {
        mutate {
          add_field => { "apache_robot" => "Hatena_Star_UserAgent" }
        }
      }
      if [apache_agent] =~ /Media\ Center\ PC/ {
        mutate {
          add_field => { "apache_robot" => "Media_Center_PC" }
        }
      }
      if [apache_agent] =~ /CCBot/ {
        mutate {
          add_field => { "apache_robot" => "CCBot" }
        }
      }
      if [apache_agent] =~ /BoardReader\ Blog\ Indexer/ {
        mutate {
          add_field => { "apache_robot" => "BoardReader_Blog_Indexer" }
        }
      }
      if [apache_agent] =~ /Applebot/ {
        mutate {
          add_field => { "apache_robot" => "Applebot" }
        }
      }
      if [apache_agent] =~ /Mail\.RU_Bot/ {
        mutate {
          add_field => { "apache_robot" => "Mail.RU_Bot" }
        }
      }
      if [apache_agent] =~ /magpie\-crawler/ {
        mutate {
          add_field => { "apache_robot" => "magpie-crawler" }
        }
      }
      if [apache_agent] =~ /SiteExplorer/ {
        mutate {
          add_field => { "apache_robot" => "SiteExplorer" }
        }
      }
      if [apache_agent] =~ /ia_archiver/ {
        mutate {
          add_field => { "apache_robot" => "ia_archiver" }
        }
      }
      if [apache_agent] =~ /rogerbot/ {
        mutate {
          add_field => { "apache_robot" => "rogerbot" }
        }
      }
      if [apache_agent] =~ /spbot/ {
        mutate {
          add_field => { "apache_robot" => "spbot" }
        }
      }
      if [apache_agent] =~ /Digg\ Feed\ Fetcher/ {
        mutate {
          add_field => { "apache_robot" => "Digg_Feed_Fetcher" }
        }
      }
      if [apache_agent] =~ /Exabot/ {
        mutate {
          add_field => { "apache_robot" => "Exabot" }
        }
      }
      if [apache_agent] =~ /linkdexbot/ {
        mutate {
          add_field => { "apache_robot" => "linkdexbot" }
        }
      }
      if [apache_agent] =~ /Steeler/ {
        mutate {
          add_field => { "apache_robot" => "Steeler" }
        }
      }
      if [apache_agent] =~ /Bumble\ Bee/ {
        mutate {
          add_field => { "apache_robot" => "Bumble_Bee" }
        }
      }
      if [apache_agent] =~ /WordPress/ {
        mutate {
          add_field => { "apache_robot" => "WordPress" }
        }
      }
      if [apache_agent] =~ /Tiny\ Tiny\ RSS/ {
        mutate {
          add_field => { "apache_robot" => "Tiny_Tiny_RSS" }
        }
      }
      if [apache_agent] =~ /Windows\-RSS\-Platform/ {
        mutate {
          add_field => { "apache_robot" => "Windows-RSS-Platform" }
        }
      }
      if [apache_agent] =~ /DotBot/ {
        mutate {
          add_field => { "apache_robot" => "DotBot" }
        }
      }
      if [apache_agent] =~ /livedoor\ FeedFetcher/ {
        mutate {
          add_field => { "apache_robot" => "livedoor_FeedFetcher" }
        }
      }
      if [apache_agent] =~ /meanpathbot/ {
        mutate {
          add_field => { "apache_robot" => "meanpathbot" }
        }
      }
      if [apache_agent] =~ /Twitterbot/ {
        mutate {
          add_field => { "apache_robot" => "Twitterbot" }
        }
      }
      if [apache_agent] =~ /Feedly/ {
        mutate {
          add_field => { "apache_robot" => "Feedly" }
        }
      }
      if [apache_agent] =~ /CRAZYWEBCRAWLER/ {
        mutate {
          add_field => { "apache_robot" => "CRAZYWEBCRAWLER" }
        }
      }
      if [apache_agent] =~ /AhrefsBot/ {
        mutate {
          add_field => { "apache_robot" => "AhrefsBot" }
        }
      }
      if [apache_agent] =~ /everrss/ {
        mutate {
          add_field => { "apache_robot" => "everrss" }
        }
      }
      if [apache_agent] =~ /Feedeen/ {
        mutate {
          add_field => { "apache_robot" => "Feedeen" }
        }
      }
      if [apache_agent] =~ /Yandex/ {
        mutate {
          add_field => { "apache_robot" => "Yandex" }
        }
      }
      if [apache_agent] =~ /Googlebot/ {
        mutate {
          add_field => { "apache_robot" => "Googlebot" }
        }
      }
      if [apache_agent] =~ /bingbot/ {
        mutate {
          add_field => { "apache_robot" => "bingbot" }
        }
      }
      if [apache_agent] =~ /BingPreview/ {
        mutate {
          add_field => { "apache_robot" => "BingPreview" }
        }
      }
      if [apache_agent] =~ /Yahoo/ {
        mutate {
          add_field => { "apache_robot" => "Yahoo" }
        }
      }
      if [apache_agent] =~ /Feedbin/ {
        mutate {
          add_field => { "apache_robot" => "Feedbin" }
        }
      }
      if [apache_agent] =~ /FreshReader/ {
        mutate {
          add_field => { "apache_robot" => "FreshReader" }
        }
      }
      if [apache_agent] =~ /AlexaToolbar/ {
        mutate {
          add_field => { "apache_robot" => "AlexaToolbar" }
        }
      }
      if [apache_agent] =~ /Baiduspider/ {
        mutate {
          add_field => { "apache_robot" => "Baiduspider" }
        }
      }
      # bad bot
      if [apache_agent] =~ /360Spider/ {
        mutate {
          add_field => { "apache_robot" => "360Spider" }
        }
      }
      if [apache_agent] =~ /MJ12bot/ {
        mutate {
          add_field => { "apache_robot" => "MJ12bot" }
        }
      }
    }
    if [apache_request] {
      ruby {
	code => "event['apache_extension'] = File.extname(event['apache_request'].split('?')[0]).delete('.')"
      }
      if [apache_extension] == "" or [apache_extension] !~ /^[a-zA-Z0-9]{2,4}$/ {
	mutate {
	  remove_field => [ "apache_extension" ]
	}
      }
    }
  }

  if [type] == "apache-error" {
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{APACHE_ERROR}" }
    }
    date {
      match => [ "apache_error_timestamp", "EEE MMM dd HH:mm:ss yyyy" ]
      timezone => "Asia/Tokyo"
    }
    if [apache_error_client_ip] {
      geoip {
	database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	source => "apache_error_client_ip"
	target => "apache_error_geoip"
      }
      mutate {
	add_field => { "apache_error_client_hostname" => "%{apache_error_client_ip}" }
      }
      dns {
	reverse => [ "apache_error_client_hostname" ]
	action => "replace"
      }
    }
  }

  # TEST implementation of parse for collectd
  if [type] == "collectd" {
    if [plugin] {
      mutate {
	rename => { "plugin" => "collectd_plugin" }
      }
    }
    if [plugin_instance] {
      mutate {
	rename => { "plugin_instance" => "collectd_plugin_instance" }
      }
    }
    if [type_instance] {
      mutate {
	rename => { "type_instance" => "collectd_type_instance" }
      }
    }
    if [value] {
      mutate {
	rename => { "value" => "collectd_value" }
      }
      mutate {
	convert => { "collectd_value" => "float" }
      }
    }
    if [collectd_plugin] == "interface" {
      mutate {
	add_field => {
	  "collectd_value_instance" => "rx"
	  "collectd_value" => "%{rx}"
	}
      }
      mutate {
	convert => {
	  "tx" => "float"
	  "collectd_value" => "float"
	}
      }
      # force clone for kibana3
      clone {
	clones => [ "tx" ]
      }
      ##### BUG EXISTS : 'if [type] == "foo"' NOT WORKING : ruby code is working #####
      ruby {
	code => "
	  if event['type'] == 'tx'
	     event['collectd_value_instance'] = 'tx'
	     event['collectd_value'] = event['tx']
          end
        "
      }
      mutate {
	replace => { "_type" => "collectd" }
	replace => { "type" => "collectd" }
	remove_field => [ "rx", "tx" ]
      }
    }
    if [collectd_plugin] == "disk" {
      mutate {
	add_field => {
	  "collectd_value_instance" => "read"
	  "collectd_value" => "%{read}"
	}
      }
      mutate {
	convert => {
	  "write" => "float"
	  "collectd_value" => "float"
	}
      }
      # force clone for kibana3
      clone {
	clones => [ "write" ]
      }
      ##### BUG EXISTS : 'if [type] == "foo"' NOT WORKING : ruby code is working #####
      ruby {
	code => "
	  if event['type'] == 'write'
	     event['collectd_value_instance'] = 'write'
	     event['collectd_value'] = event['write']
          end
        "
      }
      mutate {
	replace => { "_type" => "collectd" }
	replace => { "type" => "collectd" }
	remove_field => [ "read", "write" ]
      }
    }
    if [collectd_plugin] == "df" {
      mutate {
	add_field => {
	  "collectd_value_instance" => "free"
	  "collectd_value" => "%{free}"
	}
      }
      mutate {
	convert => {
	  "used" => "float"
	  "collectd_value" => "float"
	}
      }
      # force clone for kibana3
      clone {
	clones => [ "used" ]
      }
      ##### BUG EXISTS : 'if [type] == "foo"' NOT WORKING : ruby code is working  #####
      ruby {
	code => "
	  if event['type'] == 'used'
	     event['collectd_value_instance'] = 'used'
	     event['collectd_value'] = event['used']
          end
        "
      }
      mutate {
	replace => { "_type" => "collectd" }
	replace => { "type" => "collectd" }
	remove_field => [ "used", "free" ]
      }
    }
    if [collectd_plugin] == "load" {
      mutate {
	add_field => {
	  "collectd_value_instance" => "shortterm"
	  "collectd_value" => "%{shortterm}"
	}
      }
      mutate {
	convert => {
	  "longterm" => "float"
	  "midterm" => "float"
	  "collectd_value" => "float"
	}
      }
      # force clone for kibana3
      clone {
	clones => [ "longterm", "midterm" ]
      }
      ##### BUG EXISTS : 'if [type] == "foo"' NOT WORKING : ruby code is working #####
      ruby {
	code => "
	  if event['type'] != 'collectd'
	    event['collectd_value_instance'] = event['type']
	    event['collectd_value'] = event[event['type']]
	  end
        "
      }
      mutate {
	replace => { "_type" => "collectd" }
	replace => { "type" => "collectd" }
	remove_field => [ "longterm", "midterm", "shortterm" ]
      }
    }
  }
}

output {
  redis {
    host => "127.0.0.1"
    data_type => "list"
    key => "logstash"
  }
}
