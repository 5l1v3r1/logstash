input {
  redis {
    host => "127.0.0.1"
    data_type => "list"
    key => "logstash"
    codec => json
  }
}

filter {
  if [type] == "syslog" {
    ### "$RepeatedMsgReduction off" /etc/rsyslog.conf
    #if [message] =~ /last message repeated [0-9]+ times/ {
    #  drop { }
    #}
    ## enable high precision timestamps
    # comment out $ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat
    grok {
      match => { "message" => "(?:%{SYSLOGTIMESTAMP:syslog_timestamp}|%{TIMESTAMP_ISO8601:syslog_timestamp}) %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid:int}\])?: %{GREEDYDATA:syslog_message}" }
      add_field => {
	"syslog_received_at" => "%{@timestamp}"
	"syslog_received_from" => "%{host}"
      }
    }
    syslog_pri {
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss", "ISO8601" ]
      timezone => "Asia/Tokyo"
      locale => "en"
    }
    mutate {
      replace => { "syslog_timestamp" => "%{@timestamp}" }
    }
    # postfix details
    if [syslog_program] =~ /^postfix.*\/smtpd$/ {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTPD}" }
      }
    }
    if [syslog_program] == "postfix/smtp" or [syslog_program] == "postfix/lmtp" or [syslog_program] == "postfix/local" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTP}" }
      }
    }
    if [syslog_program] == "postfix/bounce" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_BOUNCE}" }
      }
    }
    if [syslog_program] == "postfix/qmgr" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_QMGR}" }
      }
    }
    if [syslog_program] == "postfix/anvil" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_ANVIL}" }
      }
    }
    if [syslog_program] == "postfix/cleanup" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_CLEANUP}" }
      }
    }
    if [syslog_program] == "postfix/dnsblog" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_DNSBLOG}" }
      }
    }
    if [syslog_program] == "postfix/master" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_MASTER}" }
      }
    }
    if [syslog_program] == "postfix/pickup" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_PICKUP}" }
      }
    }
    if [syslog_program] == "postfix/pipe" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_PIPE}" }
      }
    }
    if [syslog_program] == "postfix/postdrop" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_POSTDROP}" }
      }
    }
    if [syslog_program] == "postfix/postscreen" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_POSTSCREEN}" }
      }
    }
    if [syslog_program] == "postfix/sendmail" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SENDMAIL}" }
      }
    }
    if [syslog_program] == "postfix/tlsmgr" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TLSMGR}" }
      }
    }
    if [syslog_program] == "postfix/tlsproxy" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TLSPROXY}" }
      }
    }
    if [syslog_program] == "postfix/trivial-rewrite" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TRIVIAL_REWRITE}" }
      }
    }

    if [syslog_program] =~ /^postfix.*\// {
      mutate {
	replace => { "type" => "postfix" }
      }
      # process key-value data is it exists
      if [postfix_keyvalue_data] {
	kv {
	  source => "postfix_keyvalue_data"
	  include_keys => [ "from", "to", "orig_to", "proto", "helo", "size", "nrcpt", "client", "relay", "delay", "delays", "dsn", "uid", "status", "message-id" ]
	  trim => "<>,"
	  prefix => "postfix_"
	  remove_field => [ "postfix_keyvalue_data" ]
	}
	# some post processing of key-value data
	if [postfix_client] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_client" => "%{POSTFIX_CLIENT_INFO}" }
	    tag_on_failure => [ "_grok_kv_postfix_client_nomatch" ]
	    remove_field => [ "postfix_client" ]
	  }
	}
	if [postfix_relay] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_relay" => "%{POSTFIX_RELAY_INFO}" }
	    tag_on_failure => [ "_grok_kv_postfix_relay_nomatch" ]
	    remove_field => [ "postfix_relay" ]
	  }
	}
	if [postfix_delays] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_delays" => "%{POSTFIX_DELAYS}" }
	    tag_on_failure => [ "_grok_kv_postfix_delays_nomatch" ]
	    remove_field => [ "postfix_delays" ]
	  }
	}
	if [postfix_from] == "" {
	  mutate {
	    replace => { "postfix_from" => "NULL" }
	  }
	}
      }
      # Do some key-value data type conversions
      mutate {
	convert => {
	  "postfix_nrcpt" => "integer"
	  "postfix_size" => "integer"
	  "postfix_uid" => "integer"
	  "postfix_delay" => "float"
	}
      }
      if [postfix_client_ip] and [postfix_client_ip] != "unknown" {
	geoip {
	  database => "/etc/logstash/geoip/GeoLiteCity.dat"
	  source => "postfix_client_ip"
	  target => "postfix_geoip"
	}
      }
    }

    if [syslog_program] == "sshd" {
      grok {
        patterns_dir => "/etc/logstash/patterns"
        match => { "syslog_message" => "%{SSHD_LOG}" }
      }
      if [sshd_client_ip] and [sshd_client_ip] != "unknown" {
	geoip {
	  database => "/etc/logstash/geoip/GeoLiteCity.dat"
	  source => "sshd_client_ip"
	  target => "sshd_geoip"
	}
	if ![sshd_client_hostname] {
	  mutate {
	    add_field => { "sshd_client_hostname" => "%{sshd_client_ip}" }
	  }
	  dns {
	    reverse => [ "sshd_client_hostname" ]
	    action => "replace"
	  }
	}
      }
    }

    # auth.log
    if [syslog_program] == "saslauthd" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{SASLAUTHD}" }
      }
    }
  }

  if [type] == "apache" or [type] == "apache-other-vhost" or [type] == "varnish" {
    if [type] == "apache-other-vhost" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "message" => "%{APACHE_OTHER_VHOST_EXT}" }
      }
    } else {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "message" => "%{APACHE_EXT_COMBINED}" }
      }
    }
    date {
      match => [ "apache_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      timezone => "Asia/Tokyo"
      locale =>	  "en"
    }
    mutate {
      replace => { "apache_timestamp" => "%{@timestamp}" }
    }
    if [apache_client_ip] and [apache_client_ip] != "unknown" {
      geoip {
	database => "/etc/logstash/geoip/GeoLiteCity.dat"
	source => "apache_client_ip"
	target => "apache_geoip"
      }
      mutate {
	add_field => { "apache_client_hostname" => "%{apache_client_ip}" }
      }
      dns {
	reverse => [ "apache_client_hostname" ]
	action => "replace"
      }
    }
    if [apache_agent] {
      useragent {
        source => "apache_agent"
        target => "apache_useragent"
	regexes => "/etc/logstash/regexes.yaml"
      }
      ruby {
        code => "
	  bot_hash = {
            '^\"robots\"$'			=> 'robots',
	    '^\"\"$'				=> 'NULL',
	    '^\"\-\"$'				=> 'MINUS',
	    'user_agent'			=> 'Program_Miss',
	    '^\"iPhone\"$'			=> 'iPhone_Fake_google',
	    '^\"Mozilla\"$'			=> 'Mozilla_Fake_google',
	    'Java'				=> 'Java',
	    'curl'				=> 'curl',
	    'Wget'				=> 'Wget',
	    'libwww\-perl'			=> 'libwww-perl',
	    'Python\-urllib'			=> 'Python-urllib',
	    'python\-requests'			=> 'python-requests',
	    'CakePHP'				=> 'CakePHP',
	    '^\"PHP'				=> 'PHP',
	    'HTTP_Request2'			=> 'HTTP_Request2',
	    'WinHttp\.WinHttpRequest'		=> 'WinHttp.WinHttpRequest',
	    'Jakarta\ Commons\-HttpClient'	=> 'Jakarta_Commons-HttpClient',
	    'Google\-Site\-Verification'	=> 'Google-Site-Verification',
	    'GoogleImageProxy'			=> 'GoogleImageProxy',
	    'AppEngine\-Google'			=> 'AppEngine-Google',
	    'Slackbot\-LinkExpanding'		=> 'Slackbot-LinkExpanding',
	    'MS\ Search\ \d\.\d\ Robot'		=> 'MS_Search_Robot',
	    'GimmeUSAbot'	 		=> 'GimmeUSAbot',
	    'zgrab'				=> 'zgrab',
	    'Embedly'				=> 'Embedly',
	    'nlpproject\.info\ research'	=> 'nlpproject.info_research',
	    'Morfeus\ Fucking\ Scanner'		=> 'Morfeus_Fucking_Scanner',
	    'DialogSearch\.com\ Bot'		=> 'DialogSearch.com_Bot',
	    'scrutiny'				=> 'scrutiny',
	    'XoviBot'				=> 'XoviBot',
	    'BDCbot'				=> 'BDCbot',
	    'MixrankBot'			=> 'MixrankBot',
	    'moukrest\.ru'			=> 'moukrest.ru',
	    'Stratagems\ Kumo'			=> 'Stratagems_Kumo',
	    'GarlikCrawler'			=> 'GarlikCrawler',
	    'alsRobot2'				=> 'alsRobot2',
	    'finbot'				=> 'finbot',
	    'Screaming\ Frog\ SEO\ Spider'	=> 'Screaming_Frog_SEO_Spider',
	    'BCKLINKS'	      	   		=> 'BCKLINKS',
	    'Telesphorep'			=> 'Telesphorep',
	    'Telesphoreo'			=> 'Telesphoreo',
	    'ltx71'				=> 'ltx71',
	    'LinkWalker'			=> 'LinkWalker',
	    'YisouSpider'			=> 'YisouSpider',
	    'AdnormCrawler'			=> 'AdnormCrawler',
	    'crawler4j'				=> 'crawler4j',
	    'CMS\ Crawler'			=> 'CMS_Crawler',
	    'Newsify'				=> 'Newsify',
	    'wp\-poster'			=> 'wp-poster',
	    'WBSearchBot'			=> 'WBSearchBot',
	    'Blekkobot'				=> 'Blekkobot',
	    'Microsearch\.ru\ Bot'		=> 'Microsearch.ru_Bot',
	    'NetSeer\ crawler'			=> 'NetSeer_crawler',
	    'SeznamBot'				=> 'SeznamBot',
	    'Xenu\ Link\ Sleuth'		=> 'Xenu_Link_Sleuth',
	    'ShortLinkTranslate'		=> 'ShortLinkTranslate',
	    'Claritybot'			=> 'Claritybot',
	    'SMTBot'				=> 'SMTBot',
	    'ichiro'				=> 'goo',
	    'Internet\-wide\-scan\-to\-be\-removed\-from\-this\-list\-email\-info\-at\-binaryedge\.io' => 'binaryedge',
	    'yacybot'				=> 'yacybot',
	    'netEstate\ NE\ Crawler'		=> 'netEstate_NE_Crawler',
	    'HyperCrawl'    			=> 'HyperCrawl',
	    'HubSpot\ Links\ Crawler'		=> 'HubSpot_Links_Crawler',
	    'bot\-pge\.chlooe\.com'		=> 'bot-pge.chlooe.com',
	    'DomainSigmaCrawler'		=> 'DomainSigmaCrawler',
	    'R6_FeedFetcher'			=> 'R6_FeedFetcher',
	    'WebTarantula\.com'			=> 'WebTarantula.com',
	    'Morfeus\ strikes\ again'		=> 'Morfeus_strikes_again',
	    'oBot'    	       			=> 'oBot',
	    'ips\-agent'			=> 'ips-agent',
	    'SputnikBot'			=> 'SputnikBot',
	    'izsearch\.com'			=> 'izsearch.com',
	    'HeartRails_Capture'		=> 'HeartRails_Capture',
	    'PageAnalyzer'			=> 'PageAnalyzer',
	    'Indy\ Library'			=> 'Indy_Library',
	    'WWWC' 				=> 'WWWC',
	    'ICC\-Crawler'			=> 'ICC-Crawler',
	    'R6_CommentReader'			=> 'R6_CommentReader',
	    'heritrix'				=> 'heritrix',
	    'MojeekBot'				=> 'MojeekBot',
	    'Daumoa'				=> 'Daumoa',
	    'Wotbox'				=> 'Wotbox',
	    'DuckDuckGo\-Favicons\-Bot'		=> 'DuckDuckGo-Favicons-Bot',
	    'facebookexternalhit'		=> 'facebookexternalhit',
	    'Y!J\-'				=> 'Yahoo!_Japan_Bot',
	    'Lipperhey\-Kaus\-Australis'	=> 'Lipperhey-Kaus-Australis',
	    'SemrushBot'			=> 'SemrushBot',
	    'archive\.org_bot'			=> 'archive.org_bot',
	    'mobile\ goo'			=> 'mobile_goo',
	    'Hivemind'				=> 'Hivemind',
	    'BlackCrawler'			=> 'BlackCrawler',
	    'PiplBot'				=> 'PiplBot',
	    'psbot'				=> 'psbot',
	    'Findxbot'				=> 'Findxbot',
	    'Synapse'				=> 'Synapse',
	    'Nutch'				=> 'Nutch',
	    'Qwantify'				=> 'Qwantify',
	    'linkapediabot'			=> 'linkapediabot',
	    'BOT\ for\ JCE'			=> 'BOT_for_JCE',
	    'LSSRocketCrawler'			=> 'LSSRocketCrawler',
	    'GOFORITBOT'			=> 'GOFORITBOT',
	    'SurveyBot'				=> 'SurveyBot',
	    'iZSearch\.com'			=> 'iZSearch.com',
	    'masscan'				=> 'masscan',
	    'com\.apple\.Safari\.SearchHelper'	=> 'com.apple.Safari.SearchHelper',
	    'com\.apple\.WebKit\.WebContent'	=> 'com.apple.WebKit.WebContent',
	    'probethenet\.com\ scanner'		=> 'probethenet.com_scanner',
	    'MegaIndex\.ru'    			=> 'MegaIndex.ru',
	    'FlipboardRSS'			=> 'FlipboardRSS',
	    'BLEXBot'				=> 'BLEXBot',
	    'Sogou\ web\ spider'		=> 'Sogou_web_spider',
	    'RSSingBot'	 			=> 'RSSingBot',
	    'GigablastOpenSource'		=> 'GigablastOpenSource',
	    'SEOkicks\-Robot'			=> 'SEOkicks-Robot',
	    'Sage\+\+'				=> 'Sage++',
	    'NerdyBot'				=> 'NerdyBot',
	    'aiHitBot'				=> 'aiHitBot',
	    'NetcraftSurveyAgent'		=> 'NetcraftSurveyAgent',
	    'Netcraft\ Web\ Server\ Survey'	=> 'Netcraft_Web_Server_Survey',
	    'Cloud\ mapping\ experiment'	=> 'Cloud_mapping_experiment',
	    'msnbot'	     			=> 'msnbot',
	    'Hatena\ Pagetitle\ Agent'		=> 'Hatena_Pagetitle_Agent',
	    'Google\ favicon'			=> 'Google_favicon',
	    'PagesInventory'			=> 'PagesInventory',
	    'TurnitinBot'			=> 'TurnitinBot',
	    'Superfeedr\ bot'			=> 'Superfeedr_bot',
	    'Scrapy'	 			=> 'Scrapy',
	    'special_archiver'			=> 'special_archiver',
	    'Hatena\ Star\ UserAgent'		=> 'Hatena_Star_UserAgent',
	    'Media\ Center\ PC'			=> 'Media_Center_PC',
	    'CCBot' 	    			=> 'CCBot',
	    'BoardReader\ Blog\ Indexer'	=> 'BoardReader_Blog_Indexer',
	    'Applebot'	  			=> 'Applebot',
	    'Mail\.RU_Bot'			=> 'Mail.RU_Bot',
	    'magpie\-crawler'			=> 'magpie-crawler',
	    'SiteExplorer'			=> 'SiteExplorer',
	    'ia_archiver'			=> 'ia_archiver',
	    'rogerbot'				=> 'rogerbot',
	    'spbot'				=> 'spbot',
	    'Digg\ Feed\ Fetcher'		=> 'Digg_Feed_Fetcher',
	    'Exabot'	 			=> 'Exabot',
	    'linkdexbot'			=> 'linkdexbot',
	    'Steeler'				=> 'Steeler',
	    'Bumble\ Bee'			=> 'Bumble_Bee',
	    'WordPress'				=> 'WordPress',
	    'Tiny\ Tiny\ RSS'			=> 'Tiny_Tiny_RSS',
	    'Windows\-RSS\-Platform'		=> 'Windows-RSS-Platform',
	    'DotBot'				=> 'DotBot',
	    'livedoor\ FeedFetcher'		=> 'livedoor_FeedFetcher',
	    'meanpathbot'			=> 'meanpathbot',
	    'Twitterbot'			=> 'Twitterbot',
	    'Feedly'				=> 'Feedly',
	    'CRAZYWEBCRAWLER'			=> 'CRAZYWEBCRAWLER',
	    'AhrefsBot'				=> 'AhrefsBot',
	    'everrss'				=> 'everrss',
	    'Feedeen'				=> 'Feedeen',
	    'Yandex'				=> 'Yandex',
	    'Googlebot'				=> 'Googlebot',
	    'bingbot'				=> 'bingbot',
	    'BingPreview'			=> 'BingPreview',
	    'Yahoo'				=> 'Yahoo',
	    'Feedbin'				=> 'Feedbin',
	    'FreshReader'			=> 'FreshReader',
	    'AlexaToolbar'			=> 'AlexaToolbar',
	    'Baiduspider'			=> 'Baiduspider',
	    'x00_\-gawa\.sa\.pilipinas'		=> 'x00_-gawa.sa.pilipinas',
	    '360Spider'				=> '360Spider',
	    'MJ12bot'				=> 'MJ12bot',
	    'Zollard'				=> 'Linux.Trojan.Zollard'
	  }
	  bot_hash.each do |bot_re, bot_name|
	    if event['apache_agent'] =~ /#{bot_re}/
	      event['apache_robot'] = bot_name
            end
          end
        "
      }
    }
    if [apache_request] {
      ruby {
	code => "event['apache_extension'] = File.extname(event['apache_request'].split('?')[0]).delete('.')"
      }
      if [apache_extension] == "" or [apache_extension] !~ /^[a-zA-Z0-9]{1,4}$/ {
	mutate {
	  remove_field => [ "apache_extension" ]
	}
      }
    }
  }

  if [type] == "apache-error" {
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{APACHE_ERROR}" }
    }
    date {
      match => [ "apache_error_timestamp", "EEE MMM dd HH:mm:ss yyyy" ]
      timezone => "Asia/Tokyo"
      locale =>	  "en"
    }
    mutate {
      replace => { "apache_error_timestamp" => "%{@timestamp}" }
    }
    if [apache_error_client_ip] and [apache_error_client_ip] != "unknown" {
      geoip {
	database => "/etc/logstash/geoip/GeoLiteCity.dat"
	source => "apache_error_client_ip"
	target => "apache_error_geoip"
      }
      mutate {
	add_field => { "apache_error_client_hostname" => "%{apache_error_client_ip}" }
      }
      dns {
	reverse => [ "apache_error_client_hostname" ]
	action => "replace"
      }
    }
  }

  if [type] == "dpkg" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:dpkg_timestamp} %{GREEDYDATA:dpkg_message}" }
    }
    date {
      match => [ "dpkg_timestamp", "YYYY-MM-dd HH:mm:ss", "ISO8601" ]
      timezone => "Asia/Tokyo"
      locale =>	  "en"
    }
    mutate {
      replace => { "dpkg_timestamp" => "%{@timestamp}" }
    }
  }

  # zimbra mailbox.log
  if [type] == "zimbra" {
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{ZIMBRA_MAILBOX_LOG}" }
    }
    date {
      match => [ "zimbra_timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "ISO8601" ]
      timezone => "Asia/Tokyo"
      locale =>	  "en"
    }
    mutate {
      replace => { "zimbra_timestamp" => "%{@timestamp}" }
    }
    if [zimbra_account] {
      kv {
        source => "zimbra_account"
	include_keys => [ "ip", "oip", "id", "name", "aid", "aname", "cid", "mid", "ua", "via", "msgid", "item", "ds", "port" ]
	field_split => ";"
	prefix => "zimbra_account_"
	remove_field => [ "zimbra_account" ]
      }
      mutate {
	convert => {
	  "zimbra_account_id" => "integer"
	  "zimbra_account_aid" => "integer"
	  "zimbra_account_cid" => "integer"
	  "zimbra_account_mid" => "integer"
	  "zimbra_account_port" => "integer"
	}
      }
    }
    if [zimbra_account_ip] {
      geoip {
	database => "/etc/logstash/geoip/GeoLiteCity.dat"
	source => "zimbra_account_ip"
	target => "zimbra_geoip"
      }
      mutate {
	add_field => { "zimbra_account_hostname" => "%{zimbra_account_ip}" }
      }
      dns {
	reverse => [ "zimbra_account_hostname" ]
	action => "replace"
      }
    }
    if [zimbra_account_oip] {
      geoip {
	database => "/etc/logstash/geoip/GeoLiteCity.dat"
	source => "zimbra_account_oip"
	target => "zimbra_geoip"
      }
      mutate {
	add_field => { "zimbra_account_hostname" => "%{zimbra_account_oip}" }
      }
      dns {
	reverse => [ "zimbra_account_hostname" ]
	action => "replace"
      }
    }
    if [zimbra_trace_log] {
      mutate {
	add_field => { "zimbra_component" => "JAVA-Exception" }
      }
    }
  }

  # zimbra /var/log/zimbra.log (syslog format) use amavisd, clamd, opendkim logs only.
  if [type] == "zimbralog" {
    grok {
      match => { "message" => "(?:%{SYSLOGTIMESTAMP:syslog_timestamp}|%{TIMESTAMP_ISO8601:syslog_timestamp}) %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid:int}\])?: %{GREEDYDATA:syslog_message}" }
      add_field => {
	"syslog_received_at" => "%{@timestamp}"
	"syslog_received_from" => "%{host}"
      }
    }
    syslog_pri {
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss", "ISO8601" ]
      timezone => "Asia/Tokyo"
      locale =>	  "en"
    }
    mutate {
      replace => { "syslog_timestamp" => "%{@timestamp}" }
    }
    if [syslog_program] == "amavis" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{AMAVIS}" }
      }
      mutate {
	replace => { "type" => "amavis" }
      }
      if [amavis_relay_ip] {
	geoip {
	  database => "/etc/logstash/geoip/GeoLiteCity.dat"
	  source => "amavis_relay_ip"
	  target => "amavis_geoip"
	}
	mutate {
	  add_field => { "amavis_relay_hostname" => "%{amavis_relay_ip}" }
	}
	dns {
	  reverse => [ "amavis_relay_hostname" ]
	  action => "replace"
	}
      }
    } else if [syslog_program] == "clamd" {
      mutate {
	replace => { "type" => "clamd" }
      }
    } else if [syslog_program] == "opendkim" {
      mutate {
	replace => { "type" => "opendkim" }
      }
    } else {
      drop {
      }
    }
  }
  # TEST implementation of parse for sysdig
  # https://gist.github.com/jordansissel/5f260954e95085294096
  # ex. # sysdig -t a "not(proc.name = sysdig)" | /opt/logstash/bin/logstash -f /etc/logstash/conf.d/sysdig-shipper.conf
  if [type] == "sysdig" {
    # With absolute time via `sysdig -t a`
    # <evt.num> <evt.time> <evt.cpu> <proc.name> <thread.tid> <evt.dir> <evt.type> <evt.args>
    # Example:
    # 22232 1397121223.916379436 0 sysdig (2816) < write res=62 data=3452 1397121223.855286080 0 sysdig (2816) > switch next=1822 .
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{SYSDIG}" }
    }
    date {
      match => [ "sysdig_timestamp", "UNIX" ]
      timezone => "Asia/Tokyo"
      locale =>	  "en"
    }
    mutate {
      replace => { "sysdig_timestamp" => "%{@timestamp}" }
    }
    if [sysdig_kv_args] {
      kv {
	source => "sysdig_kv_args"
	include_keys => [ "addr", "args", "argument", "backlog", "cgroups", "clockid", "cmd", "comm", "cur", "cwd", "data", "dirfd", "domain", "dpid", "dqb_bhardlimit", "dqb_bsoftlimit", "dqb_btime", "dqb_curspace", "dqb_ihardlimit", "dqb_isoftlimit", "dqb_itime", "dqi_bgrace", "dqi_flags", "dqi_igrace", "egid", "env", "euid", "event_data", "event_type", "exe", "fd1", "fd2", "fd_in", "fdlimit", "fd_out", "fd", "fds", "flags", "gid", "how", "id", "ID", "image", "in_fd", "initval", "ino", "interval", "length", "linkdirfd", "linkpath", "mask", "maxevents", "max", "mode", "name", "nativeID", "newcur", "newdirfd", "newdir", "newmax", "newpath", "next", "offset", "oldcur", "olddirfd", "olddir", "oldmax", "oldpath", "op", "out_fd", "path", "peer", "pgft_maj", "pgft_min", "pgoffset", "pid", "pos", "proto", "prot", "ptid", "queuepct", "quotafilepath", "quota_fmt_out", "quota_fmt", "ratio", "request", "resource", "res", "rgid", "ruid", "sgid", "sig", "size", "source", "special", "spid", "status", "suid", "target", "tid", "timeout", "tuple", "type", "uid", "val", "vm_rss", "vm_size", "vm_swap", "vpid", "vtid", "whence" ]
	prefix => "sysdig_"
	#remove_field => [ "sysdig_kv_args" ]
      }
      mutate {
	convert => {
	  "sysdig_clockid" => "integer"
	  "sysdig_queuepct" => "integer"
	  "sysdig_nativeID" => "integer"
	  "sysdig_backlog" => "integer"
	  "sysdig_event_type" => "integer"
	  "sysdig_proto" => "integer"
	  "sysdig_ratio" => "integer"
	  "sysdig_vm_rss" => "integer"
	  "sysdig_vm_size" => "integer"
	  "sysdig_vm_swap" => "integer"
	}
      }
    }
  }
}

output {
  elasticsearch {
      embedded => false
      # cluster => "elasticsearch"
      # node_name => "logstash"
      host => "127.0.0.1"
      port => "9300"
      protocol => "transport"
      template => "/etc/logstash/elasticsearch-template.json"
      template_overwrite => true
  }

  # send to Datadog DogStatsD
  if [apache_response] and [type] != "varnish" {
    statsd {
      count => [ "apache.count.bytes", "%{apache_bytes}" ]
      increment => "apache.count.response.%{apache_response}"
      timing => [ "apache.timing.request", "%{apache_responsetime}" ]
    }
    # "apache_response" as long
    if [apache_response] >= 200 and [apache_response] <= 299 {
      statsd { increment => "apache.count.response.2XX" }
    } else if [apache_response] >= 300 and [apache_response] <= 399 {
      statsd { increment => "apache.count.response.3XX" }
    } else if [apache_response] >= 400 and [apache_response] <= 499 {
      statsd { increment => "apache.count.response.4XX" }
    } else if [apache_response] >= 500 and [apache_response] <= 599 {
      statsd { increment => "apache.count.response.5XX" }
    }
  }
}
