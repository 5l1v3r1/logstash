input {
  redis {
    host => "127.0.0.1"
    data_type => "list"
    key => "logstash"
    codec => json
  }
}

filter {
  if [type] == "syslog" {
    ### "$RepeatedMsgReduction off" /etc/rsyslog.conf
    #if [message] =~ /last message repeated [0-9]+ times/ {
    #  drop { }
    #}
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid:int}\])?: %{GREEDYDATA:syslog_message}" }
      add_field => {
	"syslog_received_at" => "%{@timestamp}"
	"syslog_received_from" => "%{host}"
      }
    }
    syslog_pri {
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      timezone => "Asia/Tokyo"
    }
    # postfix details
    if [syslog_program] =~ /^postfix.*\/smtpd$/ {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTPD}" }
      }
    }
    if [syslog_program] == "postfix/smtp" or [syslog_program] == "postfix/lmtp" or [syslog_program] == "postfix/local" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SMTP}" }
      }
    }
    if [syslog_program] == "postfix/bounce" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_BOUNCE}" }
      }
    }
    if [syslog_program] == "postfix/qmgr" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_QMGR}" }
      }
    }
    if [syslog_program] == "postfix/anvil" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_ANVIL}" }
      }
    }
    if [syslog_program] == "postfix/cleanup" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_CLEANUP}" }
      }
    }
    if [syslog_program] == "postfix/dnsblog" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_DNSBLOG}" }
      }
    }
    if [syslog_program] == "postfix/master" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_MASTER}" }
      }
    }
    if [syslog_program] == "postfix/pickup" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_PICKUP}" }
      }
    }
    if [syslog_program] == "postfix/pipe" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_PIPE}" }
      }
    }
    if [syslog_program] == "postfix/postdrop" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_POSTDROP}" }
      }
    }
    if [syslog_program] == "postfix/postscreen" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_POSTSCREEN}" }
      }
    }
    if [syslog_program] == "postfix/sendmail" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_SENDMAIL}" }
      }
    }
    if [syslog_program] == "postfix/tlsmgr" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TLSMGR}" }
      }
    }
    if [syslog_program] == "postfix/tlsproxy" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TLSPROXY}" }
      }
    }
    if [syslog_program] == "postfix/trivial-rewrite" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "syslog_message" => "%{POSTFIX_TRIVIAL_REWRITE}" }
      }
    }

    if [syslog_program] =~ /^postfix.*\// {
      mutate {
	replace => { "type" => "postfix" }
      }
      # process key-value data is it exists
      if [postfix_keyvalue_data] {
	kv {
	  source => "postfix_keyvalue_data"
	  include_keys => [ "from", "to", "orig_to", "proto", "helo", "size", "nrcpt", "client", "relay", "delay", "delays", "dsn", "uid", "status", "message-id" ]
	  trim => "<>,"
	  prefix => "postfix_"
	  remove_field => [ "postfix_keyvalue_data" ]
	}
	# some post processing of key-value data
	if [postfix_client] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_client" => "%{POSTFIX_CLIENT_INFO}" }
	    tag_on_failure => [ "_grok_kv_postfix_client_nomatch" ]
	    remove_field => [ "postfix_client" ]
	  }
	}
	if [postfix_relay] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_relay" => "%{POSTFIX_RELAY_INFO}" }
	    tag_on_failure => [ "_grok_kv_postfix_relay_nomatch" ]
	    remove_field => [ "postfix_relay" ]
	  }
	}
	if [postfix_delays] {
	  grok {
	    patterns_dir => "/etc/logstash/patterns"
	    match => { "postfix_delays" => "%{POSTFIX_DELAYS}" }
	    tag_on_failure => [ "_grok_kv_postfix_delays_nomatch" ]
	    remove_field => [ "postfix_delays" ]
	  }
	}
	if [postfix_from] == "" {
	  mutate {
	    replace => { "postfix_from" => "NULL" }
	  }
	}
      }
      # Do some key-value data type conversions
      mutate {
	convert => {
	  "postfix_nrcpt" => "integer"
	  "postfix_size" => "integer"
	  "postfix_uid" => "integer"
	  "postfix_delay" => "float"
	}
      }
      if [postfix_client_ip] {
	geoip {
	  database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	  source => "postfix_client_ip"
	  target => "postfix_geoip"
	}
      }
    }

    if [syslog_program] == "sshd" {
      grok {
        patterns_dir => "/etc/logstash/patterns"
        match => { "syslog_message" => "%{SSHD_LOG}" }
      }
      if [sshd_client_ip] {
	geoip {
	  database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	  source => "sshd_client_ip"
	  target => "sshd_geoip"
	}
      }
    }
  }

  if [type] == "apache" or [type] == "apache-other-vhost" {
    if [type] == "apache-other-vhost" {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "message" => "%{APACHE_OTHER_VHOST}" }
      }
    } else {
      grok {
	patterns_dir => "/etc/logstash/patterns"
	match => { "message" => "%{APACHE_COMBINED}" }
      }
    }
    date {
      match => [ "apache_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      timezone => "Asia/Tokyo"
    }
    if [apache_client_ip] {
      geoip {
	database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	source => "apache_client_ip"
	target => "apache_geoip"
      }
      mutate {
	add_field => { "apache_client_hostname" => "%{apache_client_ip}" }
      }
      dns {
	reverse => [ "apache_client_hostname" ]
	action => "replace"
      }
    }
    if [apache_agent] {
      useragent {
        source => "apache_agent"
        target => "apache_useragent"
      }
      if [apache_agent] =~ /^\"robots\"$/ {
        mutate {
          add_field => { "apache_robot" => "robots" }
        }
      }
      if [apache_agent] =~ /^\"\-\"$/ {
        mutate {
          add_field => { "apache_robot" => "MINUS" }
        }
      }
      if [apache_agent] =~ /user_agent/ {
        mutate {
          add_field => { "apache_robot" => "Program_Miss" }
        }
      }
      if [apache_agent] =~ /^\"iPhone\"$/ {
        mutate {
          add_field => { "apache_robot" => "iPhone_Fake_google" }
        }
      }
      if [apache_agent] =~ /^\"Mozilla\"$/ {
        mutate {
          add_field => { "apache_robot" => "Mozilla_Fake_google" }
        }
      }
      if [apache_agent] =~ /Java/ {
        mutate {
          add_field => { "apache_robot" => "Java" }
        }
      }
      if [apache_agent] =~ /curl/ {
        mutate {
          add_field => { "apache_robot" => "curl" }
        }
      }
      if [apache_agent] =~ /Wget/ {
        mutate {
          add_field => { "apache_robot" => "Wget" }
        }
      }
      if [apache_agent] =~ /libwww\-perl/ {
        mutate {
          add_field => { "apache_robot" => "libwww-perl" }
        }
      }
      if [apache_agent] =~ /Python\-urllib/ {
        mutate {
          add_field => { "apache_robot" => "Python-urllib" }
        }
      }
      if [apache_agent] =~ /python\-requests/ {
        mutate {
          add_field => { "apache_robot" => "python-requests" }
        }
      }
      if [apache_agent] =~ /HTTP_Request2/ {
        mutate {
          add_field => { "apache_robot" => "HTTP_Request2" }
        }
      }
      if [apache_agent] =~ /Google\-Site\-Verification/ {
        mutate {
          add_field => { "apache_robot" => "Google-Site-Verification" }
        }
      }
      if [apache_agent] =~ /facebookexternalhit/ {
        mutate {
          add_field => { "apache_robot" => "facebookexternalhit" }
        }
      }
      if [apache_agent] =~ /Y!J\-/ {
        mutate {
          add_field => { "apache_robot" => "Yahoo!_Japan_Bot" }
        }
      }
      if [apache_agent] =~ /Lipperhey\-Kaus\-Australis/ {
        mutate {
          add_field => { "apache_robot" => "Lipperhey-Kaus-Australis" }
        }
      }
      if [apache_agent] =~ /SemrushBot/ {
        mutate {
          add_field => { "apache_robot" => "SemrushBot" }
        }
      }
      if [apache_agent] =~ /archive\.org_bot/ {
        mutate {
          add_field => { "apache_robot" => "archive.org_bot" }
        }
      }
      if [apache_agent] =~ /mobile\ goo/ {
        mutate {
          add_field => { "apache_robot" => "mobile_goo" }
        }
      }
      if [apache_agent] =~ /Hivemind/ {
        mutate {
          add_field => { "apache_robot" => "Hivemind" }
        }
      }
      if [apache_agent] =~ /BlackCrawler/ {
        mutate {
          add_field => { "apache_robot" => "BlackCrawler" }
        }
      }
      if [apache_agent] =~ /PiplBot/ {
        mutate {
          add_field => { "apache_robot" => "PiplBot" }
        }
      }
      if [apache_agent] =~ /psbot/ {
        mutate {
          add_field => { "apache_robot" => "psbot" }
        }
      }
      if [apache_agent] =~ /Findxbot/ {
        mutate {
          add_field => { "apache_robot" => "Findxbot" }
        }
      }
      if [apache_agent] =~ /Synapse/ {
        mutate {
          add_field => { "apache_robot" => "Synapse" }
        }
      }
      if [apache_agent] =~ /Nutch/ {
        mutate {
          add_field => { "apache_robot" => "Nutch" }
        }
      }
      if [apache_agent] =~ /Qwantify/ {
        mutate {
          add_field => { "apache_robot" => "Qwantify" }
        }
      }
      if [apache_agent] =~ /linkapediabot/ {
        mutate {
          add_field => { "apache_robot" => "linkapediabot" }
        }
      }
      if [apache_agent] =~ /BOT\ for\ JCE/ {
        mutate {
          add_field => { "apache_robot" => "BOT_for_JCE" }
        }
      }
      if [apache_agent] =~ /LSSRocketCrawler/ {
        mutate {
          add_field => { "apache_robot" => "LSSRocketCrawler" }
        }
      }
      if [apache_agent] =~ /GOFORITBOT/ {
        mutate {
          add_field => { "apache_robot" => "GOFORITBOT" }
        }
      }
      if [apache_agent] =~ /SurveyBot/ {
        mutate {
          add_field => { "apache_robot" => "SurveyBot" }
        }
      }
      if [apache_agent] =~ /iZSearch\.com/ {
        mutate {
          add_field => { "apache_robot" => "iZSearch.com" }
        }
      }
      if [apache_agent] =~ /masscan/ {
        mutate {
          add_field => { "apache_robot" => "masscan" }
        }
      }
      if [apache_agent] =~ /com\.apple\.Safari\.SearchHelper/ {
        mutate {
          add_field => { "apache_robot" => "com.apple.Safari.SearchHelper" }
        }
      }
      if [apache_agent] =~ /com\.apple\.WebKit\.WebContent/ {
        mutate {
          add_field => { "apache_robot" => "com.apple.WebKit.WebContent" }
        }
      }
      if [apache_agent] =~ /probethenet\.com\ scanner/ {
        mutate {
          add_field => { "apache_robot" => "probethenet.com_scanner" }
        }
      }
      if [apache_agent] =~ /MegaIndex\.ru/ {
        mutate {
          add_field => { "apache_robot" => "MegaIndex.ru" }
        }
      }
      if [apache_agent] =~ /FlipboardRSS/ {
        mutate {
          add_field => { "apache_robot" => "FlipboardRSS" }
        }
      }
      if [apache_agent] =~ /BLEXBot/ {
        mutate {
          add_field => { "apache_robot" => "BLEXBot" }
        }
      }
      if [apache_agent] =~ /Sogou\ web\ spider/ {
        mutate {
          add_field => { "apache_robot" => "Sogou_web_spider" }
        }
      }
      if [apache_agent] =~ /RSSingBot/ {
        mutate {
          add_field => { "apache_robot" => "RSSingBot" }
        }
      }
      if [apache_agent] =~ /GigablastOpenSource/ {
        mutate {
          add_field => { "apache_robot" => "GigablastOpenSource" }
        }
      }
      if [apache_agent] =~ /SEOkicks\-Robot/ {
        mutate {
          add_field => { "apache_robot" => "SEOkicks-Robot" }
        }
      }
      if [apache_agent] =~ /Sage\+\+/ {
        mutate {
          add_field => { "apache_robot" => "Sage++" }
        }
      }
      if [apache_agent] =~ /NerdyBot/ {
        mutate {
          add_field => { "apache_robot" => "NerdyBot" }
        }
      }
      if [apache_agent] =~ /aiHitBot/ {
        mutate {
          add_field => { "apache_robot" => "aiHitBot" }
        }
      }
      if [apache_agent] =~ /NetcraftSurveyAgent/ {
        mutate {
          add_field => { "apache_robot" => "NetcraftSurveyAgent" }
        }
      }
      if [apache_agent] =~ /Netcraft\ Web\ Server\ Survey/ {
        mutate {
          add_field => { "apache_robot" => "Netcraft_Web_Server_Survey" }
        }
      }
      if [apache_agent] =~ /Cloud\ mapping\ experiment/ {
        mutate {
          add_field => { "apache_robot" => "Cloud_mapping_experiment" }
        }
      }
      if [apache_agent] =~ /msnbot\-media/ {
        mutate {
          add_field => { "apache_robot" => "msnbot-media" }
        }
      }
      if [apache_agent] =~ /Hatena\ Pagetitle\ Agent/ {
        mutate {
          add_field => { "apache_robot" => "Hatena_Pagetitle_Agent" }
        }
      }
      if [apache_agent] =~ /Google\ favicon/ {
        mutate {
          add_field => { "apache_robot" => "Google_favicon" }
        }
      }
      if [apache_agent] =~ /PagesInventory/ {
        mutate {
          add_field => { "apache_robot" => "PagesInventory" }
        }
      }
      if [apache_agent] =~ /TurnitinBot/ {
        mutate {
          add_field => { "apache_robot" => "TurnitinBot" }
        }
      }
      if [apache_agent] =~ /Superfeedr\ bot/ {
        mutate {
          add_field => { "apache_robot" => "Superfeedr_bot" }
        }
      }
      if [apache_agent] =~ /Scrapy/ {
        mutate {
          add_field => { "apache_robot" => "special_archiver" }
        }
      }
      if [apache_agent] =~ /special_archiver/ {
        mutate {
          add_field => { "apache_robot" => "special_archiver" }
        }
      }
      if [apache_agent] =~ /Hatena\ Star\ UserAgent/ {
        mutate {
          add_field => { "apache_robot" => "Hatena_Star_UserAgent" }
        }
      }
      if [apache_agent] =~ /Media\ Center\ PC/ {
        mutate {
          add_field => { "apache_robot" => "Media_Center_PC" }
        }
      }
      if [apache_agent] =~ /CCBot/ {
        mutate {
          add_field => { "apache_robot" => "CCBot" }
        }
      }
      if [apache_agent] =~ /BoardReader\ Blog\ Indexer/ {
        mutate {
          add_field => { "apache_robot" => "BoardReader_Blog_Indexer" }
        }
      }
      if [apache_agent] =~ /Applebot/ {
        mutate {
          add_field => { "apache_robot" => "Applebot" }
        }
      }
      if [apache_agent] =~ /Mail\.RU_Bot/ {
        mutate {
          add_field => { "apache_robot" => "Mail.RU_Bot" }
        }
      }
      if [apache_agent] =~ /magpie\-crawler/ {
        mutate {
          add_field => { "apache_robot" => "magpie-crawler" }
        }
      }
      if [apache_agent] =~ /SiteExplorer/ {
        mutate {
          add_field => { "apache_robot" => "SiteExplorer" }
        }
      }
      if [apache_agent] =~ /ia_archiver/ {
        mutate {
          add_field => { "apache_robot" => "ia_archiver" }
        }
      }
      if [apache_agent] =~ /rogerbot/ {
        mutate {
          add_field => { "apache_robot" => "rogerbot" }
        }
      }
      if [apache_agent] =~ /spbot/ {
        mutate {
          add_field => { "apache_robot" => "spbot" }
        }
      }
      if [apache_agent] =~ /Digg\ Feed\ Fetcher/ {
        mutate {
          add_field => { "apache_robot" => "Digg_Feed_Fetcher" }
        }
      }
      if [apache_agent] =~ /Exabot/ {
        mutate {
          add_field => { "apache_robot" => "Exabot" }
        }
      }
      if [apache_agent] =~ /linkdexbot/ {
        mutate {
          add_field => { "apache_robot" => "linkdexbot" }
        }
      }
      if [apache_agent] =~ /Steeler/ {
        mutate {
          add_field => { "apache_robot" => "Steeler" }
        }
      }
      if [apache_agent] =~ /Bumble\ Bee/ {
        mutate {
          add_field => { "apache_robot" => "Bumble_Bee" }
        }
      }
      if [apache_agent] =~ /WordPress/ {
        mutate {
          add_field => { "apache_robot" => "WordPress" }
        }
      }
      if [apache_agent] =~ /Tiny\ Tiny\ RSS/ {
        mutate {
          add_field => { "apache_robot" => "Tiny_Tiny_RSS" }
        }
      }
      if [apache_agent] =~ /Windows\-RSS\-Platform/ {
        mutate {
          add_field => { "apache_robot" => "Windows-RSS-Platform" }
        }
      }
      if [apache_agent] =~ /DotBot/ {
        mutate {
          add_field => { "apache_robot" => "DotBot" }
        }
      }
      if [apache_agent] =~ /livedoor\ FeedFetcher/ {
        mutate {
          add_field => { "apache_robot" => "livedoor_FeedFetcher" }
        }
      }
      if [apache_agent] =~ /meanpathbot/ {
        mutate {
          add_field => { "apache_robot" => "meanpathbot" }
        }
      }
      if [apache_agent] =~ /Twitterbot/ {
        mutate {
          add_field => { "apache_robot" => "Twitterbot" }
        }
      }
      if [apache_agent] =~ /Feedly/ {
        mutate {
          add_field => { "apache_robot" => "Feedly" }
        }
      }
      if [apache_agent] =~ /CRAZYWEBCRAWLER/ {
        mutate {
          add_field => { "apache_robot" => "CRAZYWEBCRAWLER" }
        }
      }
      if [apache_agent] =~ /AhrefsBot/ {
        mutate {
          add_field => { "apache_robot" => "AhrefsBot" }
        }
      }
      if [apache_agent] =~ /everrss/ {
        mutate {
          add_field => { "apache_robot" => "everrss" }
        }
      }
      if [apache_agent] =~ /Feedeen/ {
        mutate {
          add_field => { "apache_robot" => "Feedeen" }
        }
      }
      if [apache_agent] =~ /Yandex/ {
        mutate {
          add_field => { "apache_robot" => "Yandex" }
        }
      }
      if [apache_agent] =~ /Googlebot/ {
        mutate {
          add_field => { "apache_robot" => "Googlebot" }
        }
      }
      if [apache_agent] =~ /bingbot/ {
        mutate {
          add_field => { "apache_robot" => "bingbot" }
        }
      }
      if [apache_agent] =~ /BingPreview/ {
        mutate {
          add_field => { "apache_robot" => "BingPreview" }
        }
      }
      if [apache_agent] =~ /Yahoo/ {
        mutate {
          add_field => { "apache_robot" => "Yahoo" }
        }
      }
      if [apache_agent] =~ /Feedbin/ {
        mutate {
          add_field => { "apache_robot" => "Feedbin" }
        }
      }
      if [apache_agent] =~ /FreshReader/ {
        mutate {
          add_field => { "apache_robot" => "FreshReader" }
        }
      }
      if [apache_agent] =~ /AlexaToolbar/ {
        mutate {
          add_field => { "apache_robot" => "AlexaToolbar" }
        }
      }
      if [apache_agent] =~ /Baiduspider/ {
        mutate {
          add_field => { "apache_robot" => "Baiduspider" }
        }
      }
      # bad bot
      if [apache_agent] =~ /360Spider/ {
        mutate {
          add_field => { "apache_robot" => "360Spider" }
        }
      }
      if [apache_agent] =~ /MJ12bot/ {
        mutate {
          add_field => { "apache_robot" => "MJ12bot" }
        }
      }
    }
    if [apache_request] {
      ruby {
	code => "event['apache_extension'] = File.extname(event['apache_request'].split('?')[0]).delete('.')"
      }
      if [apache_extension] == "" or [apache_extension] !~ /^[a-zA-Z0-9]{1,4}$/ {
	mutate {
	  remove_field => [ "apache_extension" ]
	}
      }
    }
  }

  if [type] == "apache-error" {
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{APACHE_ERROR}" }
    }
    date {
      match => [ "apache_error_timestamp", "EEE MMM dd HH:mm:ss yyyy" ]
      timezone => "Asia/Tokyo"
    }
    if [apache_error_client_ip] {
      geoip {
	database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
	source => "apache_error_client_ip"
	target => "apache_error_geoip"
      }
      mutate {
	add_field => { "apache_error_client_hostname" => "%{apache_error_client_ip}" }
      }
      dns {
	reverse => [ "apache_error_client_hostname" ]
	action => "replace"
      }
    }
  }

  # TEST implementation of parse for collectd
  if [type] == "collectd" {
    if [plugin] {
      mutate {
	rename => { "plugin" => "collectd_plugin" }
      }
    }
    if [plugin_instance] {
      mutate {
	rename => { "plugin_instance" => "collectd_plugin_instance" }
      }
    }
    if [type_instance] {
      mutate {
	rename => { "type_instance" => "collectd_type_instance" }
      }
    }
    if [value] {
      mutate {
	rename => { "value" => "collectd_value" }
      }
      mutate {
	convert => { "collectd_value" => "float" }
      }
    }
    if [collectd_plugin] == "interface" {
      mutate {
	add_field => {
	  "collectd_value_instance" => "rx"
	  "collectd_value" => "%{rx}"
	}
      }
      mutate {
	convert => {
	  "tx" => "float"
	  "collectd_value" => "float"
	}
      }
      # force clone for kibana3
      clone {
	clones => [ "tx" ]
      }
      ##### BUG EXISTS : 'if [type] == "foo"' NOT WORKING : ruby code is working #####
      ruby {
	code => "
	  if event['type'] == 'tx'
	     event['collectd_value_instance'] = 'tx'
	     event['collectd_value'] = event['tx']
          end
        "
      }
      mutate {
	replace => { "_type" => "collectd" }
	replace => { "type" => "collectd" }
	remove_field => [ "rx", "tx" ]
      }
    }
    if [collectd_plugin] == "disk" {
      mutate {
	add_field => {
	  "collectd_value_instance" => "read"
	  "collectd_value" => "%{read}"
	}
      }
      mutate {
	convert => {
	  "write" => "float"
	  "collectd_value" => "float"
	}
      }
      # force clone for kibana3
      clone {
	clones => [ "write" ]
      }
      ##### BUG EXISTS : 'if [type] == "foo"' NOT WORKING : ruby code is working #####
      ruby {
	code => "
	  if event['type'] == 'write'
	     event['collectd_value_instance'] = 'write'
	     event['collectd_value'] = event['write']
          end
        "
      }
      mutate {
	replace => { "_type" => "collectd" }
	replace => { "type" => "collectd" }
	remove_field => [ "read", "write" ]
      }
    }
    if [collectd_plugin] == "df" {
      mutate {
	add_field => {
	  "collectd_value_instance" => "free"
	  "collectd_value" => "%{free}"
	}
      }
      mutate {
	convert => {
	  "used" => "float"
	  "collectd_value" => "float"
	}
      }
      # force clone for kibana3
      clone {
	clones => [ "used" ]
      }
      ##### BUG EXISTS : 'if [type] == "foo"' NOT WORKING : ruby code is working  #####
      ruby {
	code => "
	  if event['type'] == 'used'
	     event['collectd_value_instance'] = 'used'
	     event['collectd_value'] = event['used']
          end
        "
      }
      mutate {
	replace => { "_type" => "collectd" }
	replace => { "type" => "collectd" }
	remove_field => [ "used", "free" ]
      }
    }
    if [collectd_plugin] == "load" {
      mutate {
	add_field => {
	  "collectd_value_instance" => "shortterm"
	  "collectd_value" => "%{shortterm}"
	}
      }
      mutate {
	convert => {
	  "longterm" => "float"
	  "midterm" => "float"
	  "collectd_value" => "float"
	}
      }
      # force clone for kibana3
      clone {
	clones => [ "longterm", "midterm" ]
      }
      ##### BUG EXISTS : 'if [type] == "foo"' NOT WORKING : ruby code is working #####
      ruby {
	code => "
	  if event['type'] != 'collectd'
	    event['collectd_value_instance'] = event['type']
	    event['collectd_value'] = event[event['type']]
	  end
        "
      }
      mutate {
	replace => { "_type" => "collectd" }
	replace => { "type" => "collectd" }
	remove_field => [ "longterm", "midterm", "shortterm" ]
      }
    }
  }
  # TEST implementation of parse for sysdig
  # https://gist.github.com/jordansissel/5f260954e95085294096
  # ex. # sysdig -t a "not(proc.name = sysdig)" | /opt/logstash/bin/logstash -f /etc/logstash/conf.d/sysdig-shipper.conf
  if [type] == "sysdig" {
    # With absolute time via `sysdig -t a`
    # <evt.num> <evt.time> <evt.cpu> <proc.name> <thread.tid> <evt.dir> <evt.type> <evt.args>
    # Example:
    # 22232 1397121223.916379436 0 sysdig (2816) < write res=62 data=3452 1397121223.855286080 0 sysdig (2816) > switch next=1822 .
    grok {
      patterns_dir => "/etc/logstash/patterns"
      match => { "message" => "%{SYSDIG}" }
    }
    date {
      match => [ "sysdig_time", "UNIX" ]
      timezone => "Asia/Tokyo"
    }
    if [sysdig_kv_args] {
      kv {
	source => "sysdig_kv_args"
	include_keys => [ "addr", "args", "argument", "backlog", "cgroups", "clockid", "cmd", "comm", "cur", "cwd", "data", "dirfd", "domain", "dpid", "dqb_bhardlimit", "dqb_bsoftlimit", "dqb_btime", "dqb_curspace", "dqb_ihardlimit", "dqb_isoftlimit", "dqb_itime", "dqi_bgrace", "dqi_flags", "dqi_igrace", "egid", "env", "euid", "event_data", "event_type", "exe", "fd1", "fd2", "fd_in", "fdlimit", "fd_out", "fd", "fds", "flags", "gid", "how", "id", "ID", "image", "in_fd", "initval", "ino", "interval", "length", "linkdirfd", "linkpath", "mask", "maxevents", "max", "mode", "name", "nativeID", "newcur", "newdirfd", "newdir", "newmax", "newpath", "next", "offset", "oldcur", "olddirfd", "olddir", "oldmax", "oldpath", "op", "out_fd", "path", "peer", "pgft_maj", "pgft_min", "pgoffset", "pid", "pos", "proto", "prot", "ptid", "queuepct", "quotafilepath", "quota_fmt_out", "quota_fmt", "ratio", "request", "resource", "res", "rgid", "ruid", "sgid", "sig", "size", "source", "special", "spid", "status", "suid", "target", "tid", "timeout", "tuple", "type", "uid", "val", "vm_rss", "vm_size", "vm_swap", "vpid", "vtid", "whence" ]
	prefix => "sysdig_"
	#remove_field => [ "sysdig_kv_args" ]
      }
      mutate {
	convert => {
	  "sysdig_clockid" => "integer"
	  "sysdig_queuepct" => "integer"
	  "sysdig_nativeID" => "integer"
	  "sysdig_backlog" => "integer"
	  "sysdig_event_type" => "integer"
	  "sysdig_proto" => "integer"
	  "sysdig_ratio" => "integer"
	  "sysdig_vm_rss" => "integer"
	  "sysdig_vm_size" => "integer"
	  "sysdig_vm_swap" => "integer"
	}
      }
    }
  }
}

output {
  elasticsearch {
      embedded => false
      # cluster => "elasticsearch"
      # node_name => "logstash"
      host => "127.0.0.1"
      port => "9300"
      protocol => "transport"
      template => "/etc/logstash/elasticsearch-template.json"
      template_overwrite => true
  }
}
